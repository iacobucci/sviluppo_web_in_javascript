---
marp: true
paginate: true
---

<!-- _backgroundColor: var(--main-color) -->
<!-- _color: white -->
<!-- _paginate: false -->

# Lezione 3
## Controller

---

<script src="../node_modules/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true, theme:"neutral", mirrorActors:false});</script>

<link rel="stylesheet" href="res/styles.css">
<link rel="stylesheet" href="res/fontawesome.css">

# Il pattern MVC

Utilizziamo questo *pattern architetturale* per organizzare il codice e rendere la pagina **attiva**, cioè fare richieste *asincrone* al server e aggiornare la vista.

<div class="container">
<div class="content">

- Il **Backend** è il lato server.
	- Il **Controller** è il gestore delle richieste e delle risposte.
	- Il **Model** è la rappresentazione dei dati e delle regole di business.

- La **Frontend** è il lato client.
	- La **View** è la presentazione all'utente.
</div>

<div class="content">
<div class="container">
<div class="content">
<div class="mermaid">
%%{init: {'theme': 'neutral', 'mirrorActors': false} }%%
flowchart LR
	USER[Utente] -->|richiede| CONTROLLER[Controller]
	USER -->|vede| VIEW
	subgraph Modello
		subgraph Backend
			CONTROLLER --> MODEL[Model]
		end
		subgraph Frontend
			VIEW[View]
			CONTROLLER --> VIEW
			VIEW --> CONTROLLER
			MODEL --> VIEW
		end
	end
	style USER fill:#224466,color:#fff
</div>
</div>
</div>

</div>
</div>

---

## Diagramma di sequenza

L'utente contatta il server all'url principale e ottiene la pagina web. Poi utilizza le api per ottenere i dati.

<div class="container">
<div class="content">
<div class="mermaid" style="width: 30%">
%%{init: {'theme': 'neutral', 'mirrorActors': false} }%%
sequenceDiagram
	actor Utente
	Utente ->> Controller: richiesta iniziale
	Controller ->> View: ottiene pagina
	View -->> Utente: pagina web
	Utente ->> View: vede
	View -->> Controller: invia dati
	Controller ->> Model: persistenza dati
	Model -->> View: aggiornamento dati
	View -->> Utente: vede dati aggiornati
</div>
</div>
</div>

---

# Git

Uniamo Node e il DOM: è un buon momento per iniziare a salvare le versioni del codice che scriviamo.



---

# Backend

Utilizziamo Node.js per il backend, impostiamo il progetto:

```bash
mkdir condomini # creiamo una directory per il progetto
cd condomini # posizionamoci nella directory
npm init -y # avviamo il progetto
```

Verrà creato il file `package.json` che contiene le informazioni del progetto.

```json
{
	"name": "condomini",
	...
	"type": "module", // utilizziamo moduli ES6+
	...
	"scripts": { // aggiungiamo uno script per l'avvio
		"serve": "node server.js"
	}
}
```
Possiamo avviare il progetto con `npm run serve`.

---

## Server HTTP

Possiamo creare il nuovo file di script con `touch server.js`

```javascript
import http from 'http' // importiamo il modulo http

const app = http.createServer() // creiamo il server

app.on('request', (req, res) => { // gestiamo le richieste con una funzione di callback
	res.end('Hello, world!') // rispondiamo
})

app.listen(3000) // mettiamo in ascolto il server sulla porta 3000
```
Salviamo ed eseguiamo `npm run serve` Navigando a `http://localhost:3000`. vedremo la risposta del server. Proviamo a inviare dei marcatori HTML.

```javascript
	res.setHeader('Content-Type', 'text/html');
	res.end('<html><div style="color: red;">Hello, world!</div></html>')
```

---

## Pacchetti NPM

L'ecosistema di Node.js è basato su pacchetti, e ce ne sono molti *open source* disponibili su [npmjs.com](https://www.npmjs.com/) ed ottenibili con il comando `npm install`.

Installiamo **Express.js**.

```bash
npm install express
```

Vediamo che in `package.json` è stato aggiunto il pacchetto.

```json
"dependencies": {
	"express": "^4.18.2"
}
```

Il codice del pacchetto è salvato in `node_modules`.

È anche stato generato `package-lock.json` che *blocca* le versioni dei pacchetti.

---

## Express.js

Disponiamo i files statici nella directory `public`, che per ora faranno da *View*.

```javascript
import express from 'express'; // importiamo il modulo express

const app = express(); // creiamo l'applicazione

app.use(express.static('public')); // serviamo i files statici in public/

app.listen(3000); // mettiamo in ascolto l'applicazione sulla porta 3000
```

Express rileva in automatico il **MIME type** dei files e lo invia correttamente.

<div class="content">

| `condomini.html` | `styles.css` | `condomini.json`   | `logo.png`  |
| ---------------- | ------------ | ------------------ | ----------- |
| `text/html`      | `text/css`   | `application/json` | `image/png` |
</div>

---

### Middleware

```javascript
function loggaDataEInviaSaluto(req, res, next) {
	let date = Date();
	console.log("richiesta ricevuta in " + date);
	res.send("Hello, world, it's " + date);
}

app.use(loggaDataEInviaSaluto);
```
<div class="content" style="font-size: 16pt">

req: *Request* | res: *Response* | next: *function(Request, Response, function)*
--------|----------|---------------
url: *string*     | send: *function(string)*     | 
body: *Object* | status: *function(number)* | 
headers: *IncomingHttpHeaders*| header: *function(string, string)*  | 
</div>

---

Il browser cercherà di scaricare anche `/favicon.ico`

<img src="res/favicon_request.png" style="margin-bottom: 24px">

```javascript
function loggaDataEInviaSaluto(req, res, next) { ...  }

function ignoraFavicon(req, res, next) {
	if (req.url == '/favicon.ico') {
		res.end(); // interrompiamo la richiesta
		return;
	}
	next(); // passiamo la richiesta al prossimo middleware
}

app.use(ignoraFavicon);
app.use(loggaDataEInviaSaluto);
```

Così i middleware eseguono in sequenza e `/favicon.ico` non viene loggato.

---

### POST e GET

```javascript
app.get("/hello", (req, res) {
	res.send("Hello, world!");
});

app.post("/hello", (req, res) {
	res.send("Hello, world!");
});
```

---

fetch dal browser

form

ajax

api fetch


---

## Json

*JavaScript Object Notation* è un formato per scambiare dati. Bisogna *virgolettare* i nomi delle proprietà. Valori, array e oggetti sono valido JSON.
```json
{
    "via": "Vicolo Corto",
    "residenti":
    [
        {
            "nome": "Mario",
            "cognome": "Rossi"
        },
        {
            "nome": "Luigi",
            "cognome": "Verdi"
        }
    ]
}
```

---

invio dati con POST

console.log(res.body)
	bisogna attendere che arrivi tutto
	JSON.parse

---

body parser
	middleware

---

dati di esempio

import export

---

poplamento dell'interfaccia con fetch

1 costruire html lato server ed inviare
2 costruire html lato client con dati fetchati
	vedremo framework frontend
